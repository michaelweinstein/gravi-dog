package miweinst.gravidog;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.io.File;

import javax.swing.SwingUtilities;

import miweinst.engine.App;
import miweinst.engine.screen.Viewport;
import miweinst.engine.shape.AARectShape;
import miweinst.engine.world.PhysicsEntity;
import cs195n.Vec2f;
import cs195n.Vec2i;

public class PlayScreen extends GravidogScreen {

	protected App app;
	private Viewport _viewport;
	private GravidogWorld _gameWorld;
	private Vec2f _lastMouse;
	private float _cameraRadius = 0f; //currently, the player will always be in the center of the screen
	private final float ROTATION_SPEED = (float)Math.PI; //in radians per second

	////// DO WE USE THIS?
	//The viewport should not perform a timed rotation by a 
	//	private final float ROTATION_BUFFER = (float)Math.PI/20f; // in radians. 

	public PlayScreen(App a, File file) {
		super(a);		
		app = a;
		//Bounds of Viewport window on screen, in pixels
		Vec2f windowDim = a.getDimensions();
		AARectShape window = new AARectShape(new Vec2f(0, 0), windowDim);		

		//Instantiate world and viewport; pass reference both ways
		_viewport = new Viewport(window);
		//Semi-transparent background; overrides any properties from level editor 
		_viewport.getScreen().setOutline(new Color(15, 15, 15, 15), 4);	

		_gameWorld = new GravidogWorld(a,_viewport, file);
		_viewport.setWorld(_gameWorld);

		this.setBackgroundColor(Color.BLACK);
	}

	@Override
	public void onTick(long nanosSincePreviousTick) {
		_gameWorld.onTick(nanosSincePreviousTick);
		panToPlayer();
		rotateToPlayer(nanosSincePreviousTick);		
	}


	@Override
	public void onDraw(Graphics2D g) {
		super.onDraw(g);
		_viewport.draw(g);
	}

	@Override
	public void onKeyTyped(KeyEvent e) {
		// TODO Auto-generated method stub	
	}

	@Override
	public void onKeyPressed(KeyEvent e) {
		if (e.getKeyChar() == 'q') {
			_gameWorld.quitReset();
			System.exit(0);
		}
		if (e.getKeyChar() == 'r') {
			LevelMenuScreen.levelIncomplete();
			app.setScreen(new MainMenuScreen(app));
		}	
		_gameWorld.onKeyPressed(e);

		
	}

	@Override
	public void onKeyReleased(KeyEvent e) {
		_gameWorld.onKeyReleased(e);	
	}

	@Override
	public void onMouseClicked(MouseEvent e) {
		// TODO Auto-generated method stub		
	}

	@Override
	public void onMousePressed(MouseEvent e) {
		if (!e.isAltDown())
			_gameWorld.onMousePressed(e);		
		_lastMouse = new Vec2f(e.getX(), e.getY());
	}

	@Override
	public void onMouseReleased(MouseEvent e) {
		// TODO Auto-generated method stub		
	}

	@Override
	public void onMouseDragged(MouseEvent e) {
		if (SwingUtilities.isRightMouseButton(e)) {
			if (_lastMouse != null) {
				float dx = _lastMouse.x - e.getX();
				float dy = _lastMouse.y - e.getY();
				_viewport.panInPixels(new Vec2f(dx, dy));
			}
		}
		_gameWorld.onMouseDragged(e);	
		_lastMouse = new Vec2f(e.getX(), e.getY());
	}

	@Override
	public void onMouseMoved(MouseEvent e) {
		_gameWorld.onMouseMoved(e);
	}

	@Override
	public void onMouseWheelMoved(MouseWheelEvent e) {
		double rot = e.getWheelRotation();
		float zoom = rot < 0 ? 1.1f : 1.0f/1.1f;
		if(_viewport.getScreenSize().x/_viewport.getScale() < 5f*_gameWorld.getPlayer().getWidth() && zoom > 1f) {
			zoom = 1f;
		}
		_viewport.zoom(zoom*_viewport.getScale()); 
	}

	@Override
	public void onResize(Vec2i size) {
		super.onResize(size);
		//all in pixels
		Vec2f newSize = new Vec2f(size);
		_viewport.setScreenSize(newSize);
		
		///CHANGES LOCATION BY THE AMOUNT RESIZED (SKIP THIS)
/*		Vec2f oldSize = _viewport.getScreenSize();
		//Half the difference in sizes
		Vec2f delta2 = newSize.minus(oldSize).sdiv(2f);
		Vec2f oldLoc = _viewport.getScreenLoc();
		_viewport.setScreenLoc(new Vec2f(oldLoc.x + delta2.x, oldLoc.y + delta2.y)); */
//		System.out.println(delta2);
	}

	/** Player panning. If the player is outside the circle generated by the _cameraRadius
	 * and the center of the screen, then this method moves the viewport 
	 * such that the player is within this circle*/
	private void panToPlayer() {
		Vec2f playerLocOnScreen = _viewport.gamePointToScreen(_gameWorld.getPlayer().getLocation());
		Vec2f playerOffsetFromCenter = playerLocOnScreen.minus(_viewport.getCenterOfScreen());
		if(!playerOffsetFromCenter.isZero()) {
			Vec2f offsetNorm = playerOffsetFromCenter.normalized();
			Vec2f screenCameraOffset = offsetNorm.smult(_cameraRadius);
			if(playerOffsetFromCenter.mag() > screenCameraOffset.mag()) {	
				Vec2f panOffset = playerOffsetFromCenter.minus(screenCameraOffset);
				_viewport.panInPixels(panOffset);
			}
		}
	}

	private void rotateToPlayer(long nanosSincePreviousTick) {
		//set the goal angle (the player's current orientation)
		Vec2f dir = PhysicsEntity.GRAVITY.normalized();
		float goalTheta = 0f;
		if(dir.x != 0f) {
			goalTheta = (float) Math.atan(dir.y/dir.x); //offset from positive x axis
		} else {
			goalTheta = (float) (dir.y < 0 ? -Math.PI/2 : Math.PI/2);
		}
		if(dir.x < 0) {
			goalTheta += Math.PI; //since the range of atan is -pi/2 to pi/2 exclusive, here we get the full range
		}
		goalTheta += Math.PI/2; //convert to offset from negative y axis
		goalTheta = goalTheta%((float)Math.PI*2f); //confine to the 0 to 2pi range

		//rotate towards _goalTheta (used for timed viewport rotation)
		float rotationDir;
		float thetaOffset = _viewport.getTheta() - goalTheta;

		//confine to the 0 to 2pi range
		thetaOffset += (float)Math.PI*2f;
		thetaOffset%=(float)Math.PI*2f; 		

		if(thetaOffset < Math.PI) {
			//rotate CCW
			rotationDir = -1f;
		} else {
			//rotate CC
			rotationDir = 1f;
		}

		float rotationThisTick = rotationDir*ROTATION_SPEED*nanosSincePreviousTick/1000000000f;
		if(Math.abs(rotationThisTick) > Math.PI - Math.abs(thetaOffset - Math.PI)) {
			_viewport.setTheta(goalTheta);
		} else {
			_viewport.rotate(rotationThisTick);
		}
	}
}
